<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Functional Patterns in Java on Java Fun</title>
    <link>http://sebfisch.github.io/java-fun/</link>
    <description>Recent content in Functional Patterns in Java on Java Fun</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="http://sebfisch.github.io/java-fun/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Combinators in Isolation</title>
      <link>http://sebfisch.github.io/java-fun/docs/streams/tests/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://sebfisch.github.io/java-fun/docs/streams/tests/</guid>
      <description>Combinators in Isolation #  In Java, streams are instances of the generic type Stream&amp;lt;T&amp;gt; which has a type parameter T for the type of stream elements.
The map combinator #  The map combinator has the following signature1.
&amp;lt;R&amp;gt; Stream&amp;lt;R&amp;gt; map(Function&amp;lt;T,R&amp;gt; function); It expects a Function as argument, which is itself a generic type with type parameters for the argument and result types. The argument type of the passed function needs to match the element type of the original stream.</description>
    </item>
    
    <item>
      <title>Streams in Practice</title>
      <link>http://sebfisch.github.io/java-fun/docs/streams/practice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://sebfisch.github.io/java-fun/docs/streams/practice/</guid>
      <description>Streams in Practice #  We now discuss a small command line application demonstrating how streams help solving problems in practice.
Implementing source file search #  Our application will search through files in a given folder and print all lines containing a match for a given regular expression. We will only search in Java source files in the given folder. When searching for lines matching the regular expression /public static[^=]*\(/ in our own src folder, our application might produce output like this.</description>
    </item>
    
    <item>
      <title>Combinators in Isolation</title>
      <link>http://sebfisch.github.io/java-fun/docs/optionals/tests/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://sebfisch.github.io/java-fun/docs/optionals/tests/</guid>
      <description>Combinators in Isolation #  In Java, optionals are instances of the generic type Optional&amp;lt;T&amp;gt; which has a type parameter T for the type of wrapped elements. The combinators map, filter and flatMap discussed with streams are also available for optionals.
The map combinator #  The map combinator has the following signature1.
&amp;lt;R&amp;gt; Optional&amp;lt;R&amp;gt; map(Function&amp;lt;T,R&amp;gt; function); Apart from the result type, the type is the same as the type of map for streams.</description>
    </item>
    
    <item>
      <title>Using Optionals</title>
      <link>http://sebfisch.github.io/java-fun/docs/optionals/usage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://sebfisch.github.io/java-fun/docs/optionals/usage/</guid>
      <description>Using Optionals #  In order to discuss how to replace null checks with idiomatic use of optional combinators, we introduce types representing arithmetic expressions and implement different methods to evaluate them.
Arithmetic expressions #  Arithmetic expressions come in different variants. We restrict ourselves to representing constants and applications of binary operators for basic arithmetic operations. The different kinds of expressions are represented as different classes Num and Bin implementing the interface Exp.</description>
    </item>
    
    <item>
      <title>Combinators in Isolation</title>
      <link>http://sebfisch.github.io/java-fun/docs/parsers/tests/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://sebfisch.github.io/java-fun/docs/parsers/tests/</guid>
      <description>Combinators in Isolation #  Parsers are instances of the generic type Parser&amp;lt;A&amp;gt; which has a type parameter A for the type of produced results. Like streams and optionals, parsers also provide implementations for the combinators map, filter and flatMap. Before we observe how to combine parsers, hoewever, we first look at how to create basic parsers.
Basic parsers #  Basic parsers differ in how much input they consume as well as what result they produce.</description>
    </item>
    
    <item>
      <title>Defining Complex Parsers</title>
      <link>http://sebfisch.github.io/java-fun/docs/parsers/definition/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://sebfisch.github.io/java-fun/docs/parsers/definition/</guid>
      <description>Defining Complex Parsers #  We will now use parser combinators to define a more realistic example of a parser.
Kate&amp;rsquo;s Grammar Tool includes a famous grammar for arithmetic expressions as well as a corresponding railroad diagram:
Tests for our parser #  The diagram contains several named parts which together describe the syntax of arithmetic expressions. An interesting property of this description is that the structure of the rules follows the usual precedence rules of addition and multiplication: when parsing an expression based on this diagram the rules will be nested correctly even without corresponding parentheses.</description>
    </item>
    
    <item>
      <title>Implementing Combinators</title>
      <link>http://sebfisch.github.io/java-fun/docs/parsers/implementation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://sebfisch.github.io/java-fun/docs/parsers/implementation/</guid>
      <description>Implementing Combinators #  Until now we have seen three examples of types implementing map, filter, and flatMap combinators that can be used to define complex programs based on simpler ones. We have also seen useful properties of these combinators that can be used to reason about the meaning of programs. Some of these properties were valid regardless of the concrete type they are implemented for. As such, they help form intuitions about the meaning of those combinators that is independent of concrete types.</description>
    </item>
    
  </channel>
</rss>
